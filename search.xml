<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android开发-炫酷计算器基本实现]]></title>
    <url>%2Fpost%2F14b2e1c.html</url>
    <content type="text"><![CDATA[计算器设计：项目进度：（1）：实现基本四则运算（2）：实现基本的UI设计（3）：实现回退，清空，清屏功能（4）：实现正负数转换（5）：实现小数点运算 UI界面展示： 具体代码详见github 过程记录（1）将整个网格布局内的所有控件按所占网格比例分配屏幕宽度和屏幕高度：1234567891011121314151617181920212223242526272829303132333435 private static final String TAG = "MainActivity"; private GridLayout mGridLayout; private int columnCount; // Grid列数 private int rowCount; // Grid行数 private int screenWidth; // 屏幕宽度 private int screenHeight; // 屏幕高度 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mGridLayout = (GridLayout) findViewById(R.id.gridLayout); columnCount = mGridLayout.getColumnCount(); rowCount = mGridLayout.getRowCount(); DisplayMetrics dm = this.getResources().getDisplayMetrics(); int screenWidth = ((DisplayMetrics) dm).widthPixels; int screenHeight = dm.heightPixels;// Log.e("debug1", "row: " + rowCount + "; column: " + columnCount + "; screenwidth: " + screenWidth); for (int i = 0; i &lt; mGridLayout.getChildCount(); i++) &#123; View view = mGridLayout.getChildAt(i); if (view instanceof Button) &#123; Button button = (Button) view;// Log.d("debug1", "第" + i + "个view是button"); button.setWidth(screenWidth / columnCount); button.setHeight(screenHeight / rowCount); &#125; else if (view instanceof TextView) &#123; TextView textview = (TextView) view;// Log.d("debug1", "第" + i + "个view是textview"); textview.setWidth(screenWidth); textview.setHeight(screenHeight / rowCount); &#125; &#125; &#125; （2）0按钮的点击响应事件：12345678public void zero_clicked(View view) &#123; TextView print2 = (TextView) findViewById(R.id.print2); String s = print2.getText().toString(); if (!s.equals("0")) &#123; // 如果print2中的值不是0的话，字符串后面加0 s = s + "0"; &#125; print2.setText(s);&#125; （3）其他数字按钮点击响应事件: 12345678910public void one_clicked(View view) &#123; TextView print2 = (TextView) findViewById(R.id.print2); String s = print2.getText().toString(); if (s.equals("0")) &#123; // 如果print2文本框中的值为0的话，直接赋值为0 s = "1"; &#125; else &#123; // 如果print2文本框中的值不是0的话，字符串后面加1 s = s + "1"; &#125; print2.setText(s);&#125; （4）CE,C,D按钮点击响应事件: 12345678 public void ce_clicked(View view) &#123; TextView print1 = (TextView) findViewById(R.id.print1); TextView print2 = (TextView) findViewById(R.id.print2); String s1 = ""; // CE将print1文本框清空 String s2 = "0"; // CE将print2文本框赋值为0 print1.setText(s1); print2.setText(s2);&#125; CE清除两个文本框内容，C清除输入文本框内容，D回退一个输入字符，对应删除一部分上面CE代码即可。 （5）小数点按钮点击响应事件:12345678public void dot_clicked(View view) &#123; TextView print2 = (TextView) findViewById(R.id.print2); String s = print2.getText().toString(); if (!s.contains(".")) &#123; // 如果print2输入字符串内没有小数点，就在尾部添加一个小数点 s = s + "."; &#125; print2.setText(s);&#125; （6）正负号按钮点击响应事件:12345678910111213141516171819202122232425262728293031public void zhengfu_clicked(View view) &#123; TextView print1 = (TextView) findViewById(R.id.print1); TextView print2 = (TextView) findViewById(R.id.print2); String s1 = print1.getText().toString(); String s2 = print2.getText().toString(); if(!s1.equals("") &amp;&amp; s2.equals("0") &amp;&amp; s1.contains("=")) &#123; // 之前计算完了一个式子，那么我们将结果的正负号修改 s1 = s1.substring(s1.lastIndexOf("=") + 1, s1.length()); if(!s1.startsWith("-")) &#123; // 如果=号右边数字，即结果为正数，则改为负数 s1 = "-" + s1; &#125; else&#123; // 如果结果为负数，则改为正数 s1 = s1.substring(1, s1.length()); &#125; print1.setText(s1); &#125; else if(!s1.equals("") &amp;&amp; s2.equals("0") &amp;&amp; !s1.contains("+") &amp;&amp; !s1.contains("−") &amp;&amp; !s1.contains("×") &amp;&amp; !s1.contains("÷")) &#123; // 如果print1文本框内的字符串为一个数字，那么我们将该数字的正负颠倒 if(!s1.startsWith("-")) &#123; s1 = "-" + s1; &#125; else&#123; s1 = s1.substring(1, s1.length()); &#125; print1.setText(s1); &#125; else if(!s2.equals("0")) &#123; // 如果print2文本框内容不为0，那么我们将该字符串正负颠倒 if(!s2.startsWith("-")) &#123; s2 = "-" + s2; &#125; else &#123; s2 = s2.substring(1, s2.length()); &#125; print2.setText(s2); &#125;&#125; （7）四则运算点击响应事件:123456789101112131415161718192021222324252627public void add_clicked(View view) &#123; TextView print1 = (TextView) findViewById(R.id.print1); TextView print2 = (TextView) findViewById(R.id.print2); String s1 = print1.getText().toString(); String s2 = print2.getText().toString(); s2 = s2 + "+"; if(s1.equals("")) &#123; // 必须放在第三个判断之前，否则会异常 // 如果print1文本框为空，那么直接赋值为print2文本框内容加上+ s1 = s2; &#125; else if (s2.equals("0")) &#123; // 如果print2文本框为空，那么直接print1文本框内容加上+ s1 = s1 + "+"; &#125; else if (!Character.isDigit(s1.charAt(s1.length() - 1))) &#123; // 如果print1文本框内容最后一个字符 // 不是数字，而是运算符，那么print1内容加上print2内容再加上+ s1 = s1 + s2; &#125; else if(s1.contains("=") &amp;&amp; s2.equals("0+")) &#123; // 如果print1文本框内容还有=号，且 // print2文本框是0，那么print1文本框内容变为结果数字加上+ s1 = s1.substring(s1.lastIndexOf("=") + 1, s1.length()); s1 = s1 + "+"; &#125; else if(!s1.equals("") &amp;&amp; s2.equals("0+")) &#123; // 如果print1文本框内容不为空，print2 // 内容为0，且最后一位不是运算符，那么print1内容加上+ s1 = s1 + "+"; &#125; else &#123; // 若不为以上情况，则print1内容为print2内容加上+ s1 = s2; &#125; print1.setText(s1); print2.setText("0");&#125; （8）=号点击响应事件：12345678910111213141516171819202122 public void equals_clicked(View view) &#123; TextView print1 = (TextView) findViewById(R.id.print1); TextView print2 = (TextView) findViewById(R.id.print2); String s1 = print1.getText().toString(); String s2 = print2.getText().toString(); if (s1.equals("")) &#123; // 如果print1内容为空，那么print1内容赋值为print2内容 s1 = s2; &#125; else if (Character.isDigit(s1.charAt(s1.length() - 1))) &#123; // 如果最后一位为数字， // 那么也赋值为print2内容 s1 = s2; &#125; else &#123; // 否则进行计算，得到结果 String result = simple_calculate(s1 + s2); if(result.equals("不能除0")) &#123; s1 = result; &#125; else &#123; s1 = s1 + s2 + "=" + result;// s1 = simple_calculate(s1 + s2); &#125; &#125; print1.setText(s1); print2.setText("0"); &#125; 计算方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 public String simple_calculate(String s) &#123; int temp = 0; // 作用：保存算式中所有的运算符,并且保存每个运算符对应左右两个数字在arraayList中的索引 LinkedList&lt;Node&gt; linkedList = new LinkedList&lt;Node&gt;(); // 作用：保存算式中所有的数字，后面进行动态修改 LinkedList&lt;String&gt; arrayList = new LinkedList&lt;String&gt;(); // 遍历字符串，判断当前是否是运算符，若是则将上一个运算符到当前运算符中间内容，即数字保存 // 在arrayList中，将运算符与前后两个数值在arrayList中的索引，以及运算符对应 // 优先级保存在LinkedList中。 for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == '+') &#123; Node node = new Node(1, 1, arrayList.size(), arrayList.size() + 1); String subString = s.substring(temp, i); arrayList.add(subString); linkedList.add(node); temp = i + 1; &#125; else if (s.charAt(i) == '−') &#123; Node node = new Node(2, 1, arrayList.size(), arrayList.size() + 1); String subString = s.substring(temp, i); arrayList.add(subString); linkedList.add(node); temp = i + 1; &#125; else if (s.charAt(i) == '×') &#123; Node node = new Node(3, 2, arrayList.size(), arrayList.size() + 1); String subString = s.substring(temp, i); arrayList.add(subString); linkedList.add(node); temp = i + 1; &#125; else if (s.charAt(i) == '÷') &#123; Node node = new Node(4, 2, arrayList.size(), arrayList.size() + 1); String subString = s.substring(temp, i); arrayList.add(subString); linkedList.add(node); temp = i + 1; &#125; else if (i == s.length() - 1) &#123; String subString = s.substring(temp, s.length()); arrayList.add(subString); &#125; &#125; Collections.sort(linkedList, new NodeCompare()); // 对于整个式子的运算符进行优先级排序 // 按照排序后的运算符进行计算，key为1，2，3，4分别代表加减乘除 for(int i = 0; i &lt; linkedList.size(); i++) &#123; Node item = linkedList.get(i); BigDecimal left_value = new BigDecimal(arrayList.get(item.left_index)); BigDecimal right_value = new BigDecimal(arrayList.get(item.right_index)); BigDecimal result = new BigDecimal("0"); if(item.key == 1) &#123; result = left_value.add(right_value);// result = result.setScale(4, BigDecimal.ROUND_HALF_UP); &#125; else if(item.key == 2) &#123; result = left_value.subtract(right_value);// result = result.setScale(4, BigDecimal.ROUND_HALF_UP); &#125; else if(item.key == 3) &#123; result = left_value.multiply(right_value);// result = result.setScale(4, BigDecimal.ROUND_HALF_UP); &#125; else if(item.key == 4) &#123; if(arrayList.get(item.right_index).equals("0")) return "不能除0"; result = left_value.divide(right_value, BigDecimal.ROUND_HALF_UP);// result = result.setScale(4, BigDecimal.ROUND_HALF_UP); &#125; // 将计算结果赋值给运算符左边的数字，并且删除运算符右边的数字 arrayList.set(item.left_index, result.toString()); arrayList.remove(item.right_index); // 调整整个linkedList内结点的左右数字的索引 adjustLink(item.left_index, linkedList); &#125; return arrayList.get(0); &#125; 调整方法：123456789101112131415// 将处理完的运算符后面的所有运算符对应的左右数字的索引-1// 目的是让两个链表动态调整为第一次运算的形式public void adjustLink(int index, LinkedList&lt;Node&gt; linkedList) &#123; for (int i = 0;i &lt; linkedList.size(); i++) &#123; Node item = linkedList.get(i); if(item.left_index &gt; index) &#123; item.setLeft_index(item.left_index - 1); &#125; if(item.right_index &gt;index) &#123; item.setRight_index(item.right_index - 1); &#125; linkedList.set(i, item); &#125;&#125; 运算符的结点类：1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Comparator;public class Node &#123; public int value; // 优先级 public int key; // 加减乘除 public int left_index; // 左边数字的索引 public int right_index; // 右边数字的索引 public Node() &#123; key = 0; value = 0; left_index = 0; right_index = 0; &#125; public Node(int Key, int Value, int Left_index, int Right_index) &#123; key = Key; value = Value; left_index = Left_index; right_index = Right_index; &#125; public void setLeft_index(int left_index) &#123; this.left_index = left_index; &#125; public void setRight_index(int right_index) &#123; this.right_index = right_index; &#125;&#125;// 继承Comparator接口，重写自定义compare方法class NodeCompare implements Comparator&lt;Node&gt; &#123; @Override public int compare(Node n1, Node n2) &#123; if(n1.value &gt; n2.value) &#123; return -1; &#125; else if(n1.value &lt; n2.value) &#123; return 1; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Android</tag>
        <tag>项目设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA-Collections.sort()实现集合自定义排排序]]></title>
    <url>%2Fpost%2F750f4e3.html</url>
    <content type="text"><![CDATA[Collections.sort()简介:在日常开发中，很多时候都需要对一些数据进行排序的操作。然而那些数据一般都是放在一个集合中如：Map ，Set ，List等集合中。他们都提共了一个排序方法 sort()，要对数据排序直接使用这个方法就行，但是要保证集合中的对象是可比较的。但是如果我们存放在这些集合中的元素不是基本数据类型，比如说是我们自己写的一个类对象，那么自然的无法直接调用sort（）来进行排序。那么我们这个时候就需要重写compare（）方法。 实例：自定义的Node类123456789101112131415161718192021222324252627282930import java.util.Comparator;public class Node &#123; public int key; public int value; public Node() &#123; key = 0; value = 0; &#125; public Node(int Key) &#123; key = Key; value = 1; &#125; public Node(int Key, int Value) &#123; key = Key; value = Value; &#125;&#125;class NodeCompare implements Comparator&lt;Node&gt; &#123; @Override public int compare(Node n1, Node n2) &#123; if(n1.value &gt; n2.value) &#123; return 1; &#125; else if(n1.value &lt; n2.value) &#123; return -1; &#125; return 0; &#125;&#125; 我们在这个Node类中设置了两个成员变量key和value，后面我们就根据value来进行排序。并且我们重写了compare（）方法，来达到我们自定义排序方法的目的。 测试Sort类1234567891011121314151617181920212223242526272829303132333435import java.util.Collections;import java.util.Formatter;import java.util.LinkedList;public class sort &#123; public static void main(String args[]) &#123; LinkedList&lt;Node&gt; linkedList = new LinkedList&lt;Node&gt;(); Node n1 = new Node(1, 3); Node n2 = new Node(2, 2); Node n3 = new Node(3, 1); linkedList.addLast(n1); linkedList.addLast(n2); linkedList.addLast(n3); System.out.println("根据次数排序前:"); printNodeList(linkedList); Collections.sort(linkedList, new NodeCompare()); System.out.println("根据次数排序后:"); printNodeList(linkedList); &#125; public static void printNodeList(LinkedList&lt;Node&gt; linkedList) &#123; Formatter formatter = new Formatter(System.out); String s = "链表:"; formatter.format("%-8s", s); for(Node item: linkedList) &#123; formatter.format("%-5d", item.key); &#125; System.out.println(); s = "次数:"; formatter.format("%-8s", s); for(Node item : linkedList) &#123; formatter.format("%-5d", item.value); &#125; System.out.println(); &#125;&#125; 测试效果:]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统OS-四种页面置换算法的Java实现]]></title>
    <url>%2Fpost%2F746efcbd.html</url>
    <content type="text"><![CDATA[页面置换算法实验方法:本示例是采用页式分配存储管理方案，并通过分析计算不同页面淘汰算法情况下的访问命中率来比较各种 算法的优劣。另外也考虑到改变页面大小和实际存储器容量对计算结果的影响，从而可为算则好的算法、合适的页 面尺寸和实存容量提供依据。 本程序是按下述原则生成指令序列的：（1） 50%的指令是顺序执行的。（2） 25%的指令均匀散布在前地址部分。（3） 25%的指令均匀散布在后地址部分。示例中选用最佳淘汰算法（OPT）和最近最少使用页面淘汰算法（LRU）计算页面命中率。公式为假定虚存容量为 32K，页面尺寸从 1K 至 8K，实存容量从 4 页至 32 页 地址流初始化要求:本程序是按下述原则生成指令序列的：（1） 50%的指令是顺序执行的。（2） 25%的指令均匀散布在前地址部分。（3） 25%的指令均匀散布在后地址部分。1234567891011121314public static void init(int p, int [] address) &#123; Formatter formatter = new Formatter(System.out); System.out.println("The Virtual Address Stream As Follows:"); for(int i = 0; i &lt; p; i++) &#123; if (i &lt; 128) &#123; address[i] = 16895 + i; &#125; else if (i &lt; 192) &#123; address[i] = (int) (Math.random() * 15873); &#125; else &#123; address[i] = (int) (Math.random() * 15873) + 15873; &#125; &#125; printArray(p, address); &#125; 最佳淘汰算法(OPT):这是一种理想的算法，可用来作为衡量其他算法优劣的依据，在实际系统中是难以实现的，因为它必须先知道指令的全部地址流。由于本示例中已预先生成了全部的指令地址流，故可计算出最佳命中率。 该算法的准则是淘汰已满页表中不再访问或是最迟访问的页。这就要求将页表中的页逐个与后继指令访问的所有 页比较，如后继指令不在访问该页，则把此页淘汰，不然得找出后继指令中最迟访问的页面淘汰。可见最佳淘汰算法要花费较长的运算时间。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static double OPT(int m, int p, int [] pageno) &#123; int [] temp = new int[m]; int [] index = new int[m]; int num = 0; int flag1 = 0; int maxindex = 0; for(int i = 0; i &lt; m; i++) &#123; temp[i] = 0; &#125; for(int i = 0; i &lt; p; i++) &#123;// System.out.println(i + ": " + Arrays.toString(temp) + " " + num); flag1 = 0; maxindex = 0; for(int j = 0; j &lt; m; j++) &#123; index[j] = p; &#125; for(int j = 0; j &lt; m; j++) &#123; if(temp[j] == pageno[i]) &#123; flag1 = 1; break; &#125; if(temp[j] == 0) &#123; temp[j] = pageno[i]; num++; flag1 = 1; break; &#125; &#125; if(flag1 == 1) &#123; continue; &#125; else if(flag1 == 0) &#123; for(int j = 0; j &lt; m; j++) &#123; for(int k = i + 1; k &lt; p; k++) &#123; if(pageno[k] == temp[j]) &#123; index[j] = k; break; &#125; &#125; &#125; int max = index[0]; for(int j = 0; j &lt; m; j++) &#123; if(index[j] == p) &#123; maxindex = j; break; &#125; if(index[j] &gt; max) &#123; maxindex = j; max = index[j]; &#125; &#125;// System.out.println(Arrays.toString(index)); temp[maxindex] = pageno[i]; num++; &#125; &#125;// System.out.println(num); double rate; 最近最少使用页淘汰算法(LRU):这是一种经常使用的方法，有各种不同的实施方案，这里采用的是不断调整页表链的方法，即总是淘汰页表链链首的页，而把新访问的页插入链尾。如果当前调用页已在页表内，则把它再次调整到链尾。这样就能保证最近使用的 页，总是处于靠近链尾部分，而不常使用的页就移到链首，逐个被淘汰，在页表较大时，调整页表链的代价也是不小的。123456789101112131415161718192021 public static double LRU(int m, int p, int [] pageno) &#123; LinkedList linkList = new LinkedList(); int num = 0; for(int i = 0;i &lt; p; i++) &#123; if(linkList.size() &lt; m &amp;&amp; !linkList.contains(pageno[i])) &#123; linkList.addLast(pageno[i]); num++; &#125; else if(linkList.size() == m &amp;&amp; !linkList.contains(pageno[i])) &#123; linkList.removeFirst(); linkList.addLast(pageno[i]); num++; &#125; else if(linkList.contains(pageno[i])) &#123; linkList.remove(pageno[i]); linkList.addLast(pageno[i]); &#125; &#125; double rate; rate = 1 - ((double)num)/p;// System.out.println(rate); return rate; &#125; 先入先出算法(FIFO):优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。123456789101112131415161718 public static double FIFO(int m, int p, int [] pageno) &#123; LinkedList linkList = new LinkedList(); int num = 0; for(int i = 0;i &lt; p; i++) &#123; if(linkList.size() &lt; m &amp;&amp; !linkList.contains(pageno[i])) &#123; linkList.addLast(pageno[i]); num++; &#125; else if(linkList.size() == m &amp;&amp; !linkList.contains(pageno[i])) &#123; linkList.removeFirst(); linkList.addLast(pageno[i]); num++; &#125; &#125; double rate; rate = 1 - ((double)num)/p;// System.out.println(rate); return rate; &#125; 最近最不常用使用算法(LFU):即最不经常使用页置换算法，要求在页置换时置换引用计数最小的页，因为经常使用的页应该有一个较大的引用次数。但是有些页在开始时使用次数很多，但以后就不再使用，这类页将会长时间留在内存中，因此可以将引用计数寄存器定时右移一位，形成指数衰减的平均使用次数。12345678910111213141516171819202122232425262728 public static double LFU(int m, int p, int [] pageno) &#123; LinkedList&lt;Node&gt; linkList = new LinkedList&lt;Node&gt;(); int num = 0; for(int i = 0;i &lt; p; i++) &#123;// printNodeList(linkList);// System.out.println("添加元素: " + pageno[i]); if(linkList.size() &lt; m &amp;&amp; !contains(linkList, pageno[i])) &#123; Node node = new Node(pageno[i]); linkList.addLast(node); num++; &#125; else if(linkList.size() == m &amp;&amp; !contains(linkList, pageno[i])) &#123; Node node = new Node(pageno[i]); linkList.removeFirst(); linkList.addLast(node); num++; &#125; else if(contains(linkList, pageno[i])) &#123; int index = 0; index = find(linkList, pageno[i]); Node node = linkList.get(index); node.value++; &#125; Collections.sort(linkList, new NodeCompare()); &#125; double rate; rate = 1 - ((double)num)/p;// System.out.println(rate); return rate; &#125; 实验截图: 具体代码:详见github]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Java</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发(2)-事件绑定与布局设计]]></title>
    <url>%2Fpost%2F9d417d59.html</url>
    <content type="text"><![CDATA[实验一:实验要求:编程实现如图 1 所示功能，即单击按钮，在文本编辑框中输入的文字内容将显示到文本标签中。 实验代码:具体代码详见github。 实验结果： 实验二:实验要求:设计一个加法计算器，如图 2 所示，在前两个文本编辑框中输入证书，单击“=”按钮时，在第 3 个文本编辑框中显示这两个数之和。 实验代码:具体代码详见github 实验结果: 实验三:实验要求:设计如图 3 所示的用户界面布局。 实验代码:具体代码详见github 实验结果:]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA-LinkedList使用介绍]]></title>
    <url>%2Fpost%2Fd3734e81.html</url>
    <content type="text"><![CDATA[LinkedList使用介绍LinkedList继承于AbstractSequentialList，它可以当作一个堆栈、队列或者双端队列来使用,实际上它的实现是一个双向链表。既然是双向链表，那么它的顺序访问会非常高效，而随机访问效率比较低。借用网上dalao们总结的一张表格来看看大致的一些函数返回值与异常问题：12345 第一个元素（头部） 最后一个元素（尾部） 抛出异常 特殊值 抛出异常 特殊值插入 addFirst(e) offerFirst(e) addLast(e) offerLast(e)移除 removeFirst() pollFirst() removeLast() pollLast()检查 getFirst() peekFirst() getLast() peekLast() LinkedList的继承情况123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable LinkedList的成员变量123transient int size = 0;transient Node&lt;E&gt; first;transient Node&lt;E&gt; last; 可以看得出这就是我们之前学过的双向链表的基本实现。 LinkedList的构造函数1LinkedList() LinkedList的API12345678910111213141516171819202122232425262728293031323334353637383940返回值 函数方法boolean add(E object)void add(int location, E object)boolean addAll(Collection&lt;? extends E&gt; collection)boolean addAll(int location, Collection&lt;? extends E&gt; collection)void addFirst(E object)void addLast(E object)void clear()Object clone()boolean contains(Object object)Iterator&lt;E&gt; descendingIterator()E element()E get(int location)E getFirst()E getLast()int indexOf(Object object)int lastIndexOf(Object object)ListIterator&lt;E&gt; listIterator(int location)boolean offer(E o)boolean offerFirst(E e)boolean offerLast(E e)E peek()E peekFirst()E peekLast()E poll()E pollFirst()E pollLast()E pop()void push(E e)E remove()E remove(int location)boolean remove(Object object)E removeFirst()boolean removeFirstOccurrence(Object o)E removeLast()boolean removeLastOccurrence(Object o)E set(int location, E object)int size()&lt;T&gt; T[] toArray(T[] contents)Object[] toArray() LinkedList的遍历方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package demo;import sun.awt.image.ImageWatched;import java.util.*;public class LinkedListTest &#123; public static void main(String args[]) &#123; method1(list()); method2(list()); method3(list()); method4(list()); method5(list()); method6(list()); method7(list()); &#125; // 创建一个200000大小的对象 public static LinkedList list() &#123; LinkedList linkedList = new LinkedList(); for(int i = 0; i &lt; 100000; i++) &#123; linkedList.addLast(i); &#125; return linkedList; &#125; // 通过随机访问遍历 public static void method1(LinkedList&lt;Integer&gt; list) &#123; long start = System.currentTimeMillis(); for(int i = 0; i &lt; list.size(); i++) &#123; list.get(i); &#125; long end = System.currentTimeMillis(); long interval = end - start; System.out.println("随机访问遍历: " + interval + " ms"); &#125; // 通过迭代器遍历 public static void method2(LinkedList&lt;Integer&gt; list) &#123; long start = System.currentTimeMillis(); for(Iterator iter = list.iterator(); iter.hasNext();) &#123; iter.next(); &#125; long end = System.currentTimeMillis(); long interval = end - start; System.out.println("迭代器访问遍历: " + interval + " ms"); &#125; // 通过pollFirst()遍历 public static void method3(LinkedList&lt;Integer&gt; list) &#123; long start = System.currentTimeMillis(); while(list.pollFirst() != null)&#123; ; &#125; long end = System.currentTimeMillis(); long interval = end - start; System.out.println("pollFirst()访问遍历: " + interval + " ms"); &#125; // 通过pollLast()遍历 public static void method4(LinkedList&lt;Integer&gt; list) &#123; long start = System.currentTimeMillis(); while(list.pollLast() != null)&#123; ; &#125; long end = System.currentTimeMillis(); long interval = end - start; System.out.println("pollLast()访问遍历: " + interval + " ms"); &#125; // 通过for-each遍历 public static void method5(LinkedList&lt;Integer&gt; list) &#123; long start = System.currentTimeMillis(); for(Integer item : list) &#123; ; &#125; long end = System.currentTimeMillis(); long interval = end - start; System.out.println("for-each访问遍历: " + interval + " ms"); &#125; // 通过removeFirst()遍历 public static void method6(LinkedList&lt;Integer&gt; list) &#123; long start = System.currentTimeMillis(); try &#123; while(list.removeFirst() != null) &#123; ; &#125; &#125; catch (NoSuchElementException e) &#123; &#125; long end = System.currentTimeMillis(); long interval = end - start; System.out.println("removeFirst()访问遍历: " + interval + " ms"); &#125; // 通过removeLast()遍历 public static void method7(LinkedList&lt;Integer&gt; list) &#123; long start = System.currentTimeMillis(); try &#123; while(list.removeLast() != null) &#123; ; &#125; &#125; catch (NoSuchElementException e) &#123; &#125; long end = System.currentTimeMillis(); long interval = end - start; System.out.println("removeLast()访问遍历: " + interval + " ms"); &#125;&#125; 效果:可以发现遍历LinkedList时，使用removeFirst()以及removeLast()或者pollFirst()以及pollLast()效率比较高，但是它们遍历时，会删除数据，如果只想读取，但不希望修改数据的时候，最好使用for-each方式来遍历，而且这个方法可以不需要担心数组越界的问题。但是最好不要使用随机访问的方式来遍历LinkedList。 removeFirst()和pollFirst()的区别pollFirst()方法：用于取首元素；removeFirst()方法: 用于删除首元素，同时返回首元素；测试实例：12345678910111213141516171819202122232425262728293031323334353637383940package demo;import sun.awt.image.ImageWatched;import java.util.*;public class pull_remove &#123; public static void main(String args[]) &#123; System.out.println("list: " + getList()); pollTest(getList()); removeTest(getList()); &#125; public static LinkedList getList() &#123; LinkedList list = new LinkedList(); for(int i = 0; i &lt; 5; i++) &#123; list.addLast(i+1); &#125; return list; &#125; // pollFirst()方法 public static void pollTest(LinkedList&lt;Integer&gt; list) &#123; int i = 1; while(list.pollFirst() != null) &#123; System.out.println("poll第" + i + "次成功"); i++; &#125; &#125; // removeFirst()方法 public static void removeTest(LinkedList&lt;Integer&gt; list) &#123; int i = 1; try &#123; while(list.removeFirst() != null) &#123; System.out.println("remove第" + i + "次成功"); i++; &#125; &#125; catch (NoSuchElementException e) &#123; System.out.println("第" + i + "次remove出现问题"); &#125; &#125;&#125; 效果: 解析:removeFirst在LinkedList为空的时候进行remove操作会抛出一个NoSuchElement的异常;pollFirst在LinkedList为空的时候进行poll操作则会返回一个null; 综上:当我们需要连续取空一个链表的时候，应该使用pull操作而不应该使用remove操作。]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django导入本地CSS/JS文件]]></title>
    <url>%2Fpost%2F54a83838.html</url>
    <content type="text"><![CDATA[Django 使用本地CSS / JS文件之前一直在纠结Django的html文件如何引入本地CSS和JS，但是找了很多资料都没能成功，后来终于找到了一个新版本Django能使用的方法。 创建一个static文件夹在Django项目目录下，manage.py 同层级下创建一个名为 static 的文件夹，我们将CSS和JS甚至是Image等文件放到这个文件夹下。例如： 修改setting.py配置在末尾添加代码: 123456789STATIC_URL = '/static/'HERE = os.path.dirname(os.path.abspath(__file__))HERE = os.path.join(HERE, '../')STATICFILES_DIRS = ( # Put strings here, like "/home/html/static" or "C:/www/django/static". # Always use forward slashes, even on Windows. # Don't forget to use absolute paths, not relative paths. os.path.join(HERE, 'static/'),) 当然我们也可以修改存放JS/CSS的文件夹名称，此处就不多言了，dalao们自己去修改上面的那串代码吧。 样例: 导入方式我们在完成了上面的所有工作后，只需要在需要导入的位置以下面的方式导入就行。 12&lt;link rel="stylesheet" type="text/css" href="../static/css/style.css"&gt;&lt;script type="text/javascript" src="../static/js/jquery.min.js"&gt;&lt;/script&gt; 大功告成!0.0]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-next主题博客控制评论系统特定页面存在]]></title>
    <url>%2Fpost%2F5da274e4.html</url>
    <content type="text"><![CDATA[控制评论系统显示与隐藏hexo博客相关问题:大家在使用hexo部署博客的时候可能会发现，对于不同的页面，hexo并没有考虑分类页面，标签页面或者说是其他的页面是否需要评论系统的存在。个人感觉既然只是分类页面，标签页面，那么只起到一个汇总的作用，可能并不需要大家评论什么，而且在我的背景下，这个评论系统就显得非常多余，而且贼丑，所以能干（强迫症）的我选择去调整一下。 hexo默认配置：我们的目的是让评论系统只存在于我们需要的页面，比如说文章页面。那么我们很自然的就会想到去修改相关的布局文件1MySelfBolg/themes/next/layout/_layout.swig 在基本布局中，我们直接搜索comments（Ctrl+F）,发现：12345&lt;div id="content" class="content"&gt; &#123;% block content %&#125;&#123;% endblock %&#125;&lt;/div&gt;&#123;% include '_partials/comments.swig' %&#125; // 划重点&lt;/div&gt; 这就是告诉我们还得去看看这个comments.swig文件，看看这个评论系统的布局设置。1&#123;% if page.comments %&#125; // 划重点，这个是第一行的代码 这个代表如果页面的comments属性为true，则选择渲染评论系统，那么我们就得想办法，让页面comments属性为false。 失败方案:一开始我的想法是在_layout.swig基本布局文件中，设置if语句，判断如果页面是文章页面才选择渲染，但是一直报错，可能是我的语句有点问题，所以就没达到目的，后来我选择了上面说的那种设置页面属性的方法。如果有dalao 能在_layout.swig 用if语句达到过滤分类页面等的效果的话，希望能在下方留言，我看到会修改本篇文章，接下来讲讲修改属性的方法。 成功方案:我找到MySelfBlog/source/categories/index.md 文件，用Typora 编辑打开，发现123title: 标签date: 2018-11-25 12:37:40type: "tags" 然后我们添加一条属性:1comments: false 修改后如下:修改成功后，我们在git上12hexo generatehexo start -debug 修改成功!!! 原本的样式: 修改后的样式:是不是看上去和谐多了呢?0.0]]></content>
      <categories>
        <category>hexo-next配置</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB最新安装详解与诸多问题处理]]></title>
    <url>%2Fpost%2F956c615f.html</url>
    <content type="text"><![CDATA[MongoDB安装过程:源程序的下载:官网下载地址:点此转入下载页面根据你的系统下载 32 位或 64 位的 .msi 文件(或者也可以下载ZIP压缩包),版本(version)安全起见选（current version），不要选最新的，操作系统按照自己的版本选，Package选MSI（ZIP也可以，不过没必要），下载后双击该文件，按操作提示安装即可。 程序安装流程:启动安装程序后，一路Next，直到如图位置:我们选择Custom自定义安装。接着就到了:这里我们选择自定义安装目录，接着Next。又到了：这个位置的两个目录最好不要改动，否则可能会出现蜜汁问题，所以No-Zuo-No-Die,乖乖的Next。注意：这里很关键，要取消勾选，我们选择不安装图形化界面，否则可能会安装很久很久很久……（网上有人安装了好久好久，最后只好Kill了进程，重新安装）注意:中间安装可能会出现问题,问题如下:解决方法就是选择Ignore,直接忽略这个问题，我们放到后面去处理服务的问题。如果你是个很有毅力的boy or girl，可以选择Retry，那么结果不出意外的话，还是会出现这个弹窗，然后重复以上……直到你放弃治疗，Ignore。 最后，恶心的安装流程就结束了。安装完了之后，大概的目录文件如图: MongoDB配置启动MongoDB将数据目录存储在 db 目录下。但是这个数据目录不会主动创建，我们在安装完成后需要创建它(具体意思看不懂也无所谓，按着做就行)。例如:我们之前MongoDB安装在了D:\mongodb目录下;我们进入到该目录下的data目录中,即D:\mongodb\data，应该是空的;我们在这个目录下创建一个db文件夹,即D:\mongodb\data\db; 注意:db文件夹作为安装目录\data\的备用目录，启动时，使用的是安装目录例如:D:\mongodb\bin\下的mongod.exe，如果直接启动，实际使用的是C:\data\db\ 为数据库文件存储目录，需要确保该目录存在。 可以使用–dbpath “安装目录\data\db” 显式指定该目录为存储位置，来启动MongoDB，如：1D:\mongodb\bin&gt;mongod.exe --dbpath "D:\mongodb\data\db" 启动成功，效果如下:说明此时MongoDB已经开启，浏览器访问 本地27017端口页面，页面上输出：It looks like you are trying to access MongoDB over HTTP on the native driver port.说明MongoDB已经启动了，且它的默认端口(27017)没有被占用。然后，我们要再打开一个CMD命令行（千万别关闭之前那个CMD，否则MongoDB服务就停了），CD到bin目录下(例如:D:\mongodb\bin),输入:mongo(或者mongo.exe)，启动mongoDB的操作终端,如下:简单实验:1234&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GB MongoDB配置服务打开任务管理器，检查本地MongoDB服务，因为我们在安装时勾选了，所以按理来说是有这个服务的，从services.msc里可以看到：或者在任务管理器上，类似于这样:注意:但是这里有可能有点不同，可能你的MongoDB服务是关闭的，而且启动不了这项服务,并且出现下面这样的响应:解决方案:使用管理员身份打开CMD，然后删除安装时默认创建的MongoDB服务(注意这里的服务名要换成你本机的,如果你的服务名不同的话)。1sc delete MongoDB 然后我们使用下面这一行命令重新创建MongoDB服务:1D:\mongodb\bin\mongod.exe --dbpath "D:\mongodb\data" --logpath "D:\mongodb\log\db.log" --install --serviceName "mongo" --logappend --directoryperdb 创建成功之后可以在任务管理器或者服务界面(services.msc)看到MongoDB的服务(mongo)，然后选中，右键启动就可以了，启动后如下: 当然你也可以使用命令启动服务,这里的服务名换成你自己设置的服务名:1net start mongo 另外，建议将MongoDB的bin目录的路径添加的系统的环境变量中去，方便在命令行打开查看mongodb数据库。否则我们启动的时候，每次都需要CD到bin目录，运行mongo.exe，所以我们可以通过添加环境变量的方法来简化操作。设置环境变量:添加你的bin目录:之后就可以在MongoDB服务开启的状态下，直接CMD通过mongo命令启动MongoDB了,不需要CD到bin目录，再开启mongo。是不是很方便呢?注意:其中也有可能出现这个问题:报错“拒绝访问”:1232016-11-01T20:52:21.647+0800 I CONTROL [main] Trying to install Windows service ‘MongoDB'2016-11-01T20:52:21.648+0800 I CONTROL [main] Error connecting to the Service Control Manager: 拒绝访问。 原因：未使用管理员身份运行CMD解决方案: 找到命令处理程序C:\Windows\System32\cmd.exe右键以管理员身份运行。]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA-输出数组元素的方法汇总]]></title>
    <url>%2Fpost%2F933a9886.html</url>
    <content type="text"><![CDATA[输出数组元素:一般来说，我们可以通过for循环遍历元素输出所有元素，但是在java中我们有更多的方法来达到我们的目的。比如说封装的Arrays类就可以很好的帮助我们处理数组的输出问题,也可以通过for-each来缩短代码量,甚至我们可以选择通过Java的泛型来自己写一个适合大多数数据对象的输出函数。总的来说，归纳有以下几种方法: 一维数组:定义变量：1234int[] array1 = &#123;1, 2, 3&#125;;char[] array2 = &#123;'你', '我', '他'&#125;;Integer[] intArray = &#123;1, 2, 3&#125;;Character[] charArray = &#123;'你', '我', '他'&#125;; (1)for循环12345678for (int i = 0; i &lt; array1.length; i++) &#123; System.out.print(array1[i] + " ");&#125;System.out.println();for (int i = 0; i &lt; array2.length; i++) &#123; System.out.print(array2[i] + " ");&#125;System.out.println(); 结果截图: (2)for-each循环12345678for (int i : array1) &#123; System.out.print(i + " ");&#125;System.out.println();for (char i : array2) &#123; System.out.print(i + " ");&#125;System.out.println(); 结果截图: (3)利用Arrays类的toString方法12System.out.println(Arrays.toString(array1));System.out.println(Arrays.toString(array2)); 结果截图: (4)利用泛型自己写一个输出函数123456789printArray(intArray); // 输出函数printArray(charArray); // 输出函数// 以下为自定义输出函数public static &lt;E&gt; void printArray(E[] inputArray)&#123; for(E element : inputArray) &#123; System.out.printf("%s ", element); &#125; System.out.println();&#125; 结果截图: 二维数组(多维数组):定义变量:1234int[][] array3 = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;;char[][] array4 = &#123;&#123;'你', '我'&#125;, &#123;'他', '她'&#125;&#125;;Integer[][] intArray2 = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;;Character[][] charArray2 = &#123;&#123;'你', '我'&#125;, &#123;'他', '她'&#125;&#125;; (1)for循环12345678910111213System.out.println("第一种方法(for循环):");for(int i = 0; i &lt; array3.length; i++)&#123; for(int j = 0; j &lt; array3[i].length; j++)&#123; System.out.print(array3[i][j] + " "); &#125; System.out.println();&#125;for(int i = 0; i &lt; array4.length; i++)&#123; for(int j = 0; j &lt; array4[i].length; j++)&#123; System.out.print(array4[i][j] + " "); &#125; System.out.println();&#125; 结果截图: (2)for-each循环123456789101112for(int[] i : array3)&#123; for(int j : i)&#123; System.out.print(j + " "); &#125; System.out.println();&#125;for(char[] i : array4)&#123; for(char j : i)&#123; System.out.print(j + " "); &#125; System.out.println();&#125; 结果截图: (3)利用Arrays类的deepToString方法12System.out.println(Arrays.deepToString(array3));System.out.println(Arrays.deepToString(array4)); 结果截图: (4)利用泛型自己写一个输出函数1234567891011printArray2(intArray2); // 输出函数printArray2(charArray2); // 输出函数// 以下为自定义输出函数public static &lt;E&gt; void printArray2(E[][] inputArray)&#123; for(E[] element1 : inputArray)&#123; for(E element2 : element1)&#123; System.out.printf("%s ", element2); &#125; System.out.println(); &#125;&#125; 结果截图: 测试代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.util.Arrays;public class out_array &#123; public static void main(String[] args) &#123; int[] array1 = &#123;1, 2, 3&#125;; char[] array2 = &#123;'你', '我', '他'&#125;; int[][] array3 = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;; char[][] array4 = &#123;&#123;'你', '我'&#125;, &#123;'他', '她'&#125;&#125;; Integer[] intArray = &#123;1, 2, 3&#125;; Character[] charArray = &#123;'你', '我', '他'&#125;; Integer[][] intArray2 = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;; Character[][] charArray2 = &#123;&#123;'你', '我'&#125;, &#123;'他', '她'&#125;&#125;; System.out.println("一维数组输出:"); System.out.println("第一种方法(for循环):"); for (int i = 0; i &lt; array1.length; i++) &#123; System.out.print(array1[i] + " "); &#125; System.out.println(); for (int i = 0; i &lt; array2.length; i++) &#123; System.out.print(array2[i] + " "); &#125; System.out.println(); System.out.println("第二种方法(for-each循环)"); for (int i : array1) &#123; System.out.print(i + " "); &#125; System.out.println(); for (char i : array2) &#123; System.out.print(i + " "); &#125; System.out.println(); System.out.println("第三种方法(利用Arrays类的toString方法):"); System.out.println(Arrays.toString(array1)); System.out.println(Arrays.toString(array2)); System.out.println("第四种方法(利用泛型自己写一个输出函数):"); printArray(intArray); printArray(charArray); System.out.println("二维数组输出方法:"); System.out.println("第一种方法(for循环):"); for(int i = 0; i &lt; array3.length; i++)&#123; for(int j = 0; j &lt; array3[i].length; j++)&#123; System.out.print(array3[i][j] + " "); &#125; System.out.println(); &#125; for(int i = 0; i &lt; array4.length; i++)&#123; for(int j = 0; j &lt; array4[i].length; j++)&#123; System.out.print(array4[i][j] + " "); &#125; System.out.println(); &#125; System.out.println("第二种方法(for-each循环:"); for(int[] i : array3)&#123; for(int j : i)&#123; System.out.print(j + " "); &#125; System.out.println(); &#125; for(char[] i : array4)&#123; for(char j : i)&#123; System.out.print(j + " "); &#125; System.out.println(); &#125; System.out.println("第三种方法(利用Arrays类的deepToString方法):"); System.out.println(Arrays.deepToString(array3)); System.out.println(Arrays.deepToString(array4)); System.out.println("第四种方法(利用泛型自己写一个输出函数):"); printArray2(intArray2); printArray2(charArray2); &#125; public static &lt;E&gt; void printArray(E[] inputArray)&#123; for(E element : inputArray) &#123; System.out.printf("%s ", element); &#125; System.out.println(); &#125; public static &lt;E&gt; void printArray2(E[][] inputArray)&#123; for(E[] element1 : inputArray)&#123; for(E element2 : element1)&#123; System.out.printf("%s ", element2); &#125; System.out.println(); &#125; &#125;&#125; 总体结果:一维数组: 二维数组（多维数组）:]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA-codePoint和length的区别]]></title>
    <url>%2Fpost%2Ff442d1f1.html</url>
    <content type="text"><![CDATA[原理差异:length() 方法返回的String字符串对应UTF-16编码需要的代码单元数量，但JAVA用的Unicode字符集并不能通过一个代码单元来代表所有的字符。对于大多数的常用Unicode字符可以仅需要一个代码单元就可以表示，但是对于一部分的特殊字符需要两个代码单元才能成功表示。 codePointCount() 方法，通过12String str = "Hello world";int strLength = str.codePointCount(0, str.length()) // 返回字符串长度 方法的调用，我们可以得到码点数量，也就是实际意义上的字符串长度。 所以通俗来讲，就是说length() 是实际上电脑中以UTF-16编码存储的字符个数。而codePointCount() 方法返回的是我们认为的字符串长度，是实际上的字符个数。 附带codePointCount()方法的解析:12345public int codePointCount(int beginIndex, int endIndex)// beginIndex -- 这是该在文本范围的第一个字符索引。// endIndex -- 这是文本范围的最后一个字符之后的索引。// 相当于对于字符串String[beginIndex, endIndex-1]求解码点数量// 也可以认为是对于[beginIndex, endIndex)左闭右开范围的字符数目 代码测试:12345678910111213141516public class codepoint &#123; public static void main(String[] args)&#123; String str1 = "hello"; String str2 = "\uD835\uDD68"; int n1 = str1.length(); int n2 = str1.codePointCount(0, n1); int n3 = str2.length(); int n4 = str2.codePointCount(0, n3); System.out.println("String1:" + str1); System.out.println("String1.length() return:" + n1); System.out .println("String1.Codepointcount() return:" + n2); System.out.println("String2:" + str2); System.out.println("String2.length() return:" + n3); System.out .println("String2.Codepointcount() return:" + n4); &#125;&#125; 测试结果:]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发(1)-输出字符并修改字体大小和颜色]]></title>
    <url>%2Fpost%2F1792901c.html</url>
    <content type="text"><![CDATA[实验要求：在Android Studio虚拟机的屏幕上输出学号和中英文名。 实验过程：赋值给控件文本内容粗暴方法：定位到activity_main.xml文件下，修改android:text属性为16121198-符子坤-zikunfu，但是呢，我们会发现出现了一定的问题，如图，我们获得了一个警告，这个警告在这个情况下代表着我们可能是直接对控件内容进行了赋值。 可行方法:解决方案：在Android中建议引用全局变量，将我们所需要内容写在strings.xml文件内，通过以下方式进行赋值。然后我们在activity_main.xml文件下,通过1android: text="@string/author_id_name" 来实现对文本内容的赋值。 修改控件字体颜色同样，我们也可以使用这种方法来对文本内容的颜色进行修改，在colors.xml文件下，添加对应的颜色变量，例如：我们选择了红色red，然后在activity_main.xml文件下使用1android:textColor="@color/red" 来设置文本内容的字体颜色。 修改控件字体大小后面呢，我们可以对字体的大小也进行修改，这里我们设置为30sp（按照官方文档最好使用sp）。 实验结果:最后，我们Run “app”就可以在虚拟机上看到所需要的学号,中英文名字显示在屏幕的中央了。]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-next主题博客自定义设置标签页面的标签样式]]></title>
    <url>%2Fpost%2F1ca6df66.html</url>
    <content type="text"><![CDATA[修改标签样式一直感觉标签页的这个标签样式非常难看，又小又灰，换了背景图之后显得连看都看不清楚了，所以我就打算去自己修改一下这个样式，让他变的和谐起来。不过呢，在这个修改的过程中发现了这个东东竟然修改起来很麻烦，它不是由一个class类别属性，分配到某一个预定义的类别上的，也就是说它不是外联样式（CSS外联样式表设定），而是内联样式决定其样式。如图：标签对应的样式：由于这些标签的样式都是内联样式，所以我们就无法通过自定义样式表来修改这些标签的样式，因为内联样式的优先级是大于外联样式的，所以即使我们自定义样式，这些标签样式也不会被修改。那么我们为了修改这些标签的样式，只能去寻找这些标签的生成代码，然后在生成代码里修改样式。我们审查元素，发现上级class是post-body,然后我们到页面生成文件page.swig中寻找，该文件位置MySelfBlog/themes/next/layout/page.swig,找到PAGE BODY代码块，很快就发现了我们的目标：找到了罪魁祸首，那么我们就只需要按自己的需要修改对应的参数就哦啦，我最终修改为：123&lt;div class="tag-cloud-tags"&gt; &#123;&#123; tagcloud(&#123;min_font: 20, max_font: 30, amount: 300, color: true, start_color: '#555', end_color: '#111'&#125;) &#125;&#125;&lt;/div&gt; 效果对比：原样式：最终样式:个人感觉还是好看了点，不是吗？0.0]]></content>
      <categories>
        <category>hexo-next配置</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-next主题博客添加分类，标签页以及自定义样式]]></title>
    <url>%2Fpost%2Fa0fe0969.html</url>
    <content type="text"><![CDATA[添加分类选项创建分类页并添加“type”属性通过命令行或者终端定位到博客所在根目录，例如MySelfBlog/ ,执行命令:1hexo new page categories 创建分类页，成功后提示：1INFO Created: ***\MySelfBlog\source\categories\index.md 根据上面的路径找到对应的index.md 文件，打开后默认内容应该是：1234---title: categoriesdate: 2018-11-25 13:47:40--- 如果我们希望分类页的标题显示为中文的分类，那么我们可以修改将title: categories 修改为title: 分类。接着我们需要修改这个文件，最终为：12345---title: 分类date: 2018-11-25 13:47:40type: "categories"--- 最后保存文件。 给文章添加“categories”属性，划分类别将需要分类的文章添加categories属性。例如：123456---title: Hexo-next主题博客博文插入图片date: 2018-11-24 22:22:31categories:- hexo-next配置--- 这样这篇文章就归类为hexo-next配置类别了。注意：hexo规定一篇文章只能属于一个分类，如果categories下方出现两个属性（例如：hexo-next配置；图片插入），那么hexo不会将这篇文章归为两个分类，而是将分类嵌套，这篇文章将属于hexo-next配置下的图片插入分类。这样我们就可以从分类页面上看到我们设置了的博文。效果如下: 添加标签选项创建标签页并添加“type”属性通过命令行或者终端定位到博客所在根目录，例如MySelfBlog/ ,执行命令:1hexo new page tags 创建分类页，成功后提示：1INFO Created: ***\MySelfBlog\source\tags\index.md 根据上面的路径找到对应的index.md 文件，打开后默认内容应该是：1234---title: tagsdate: 2018-11-25 13:47:40--- 如果我们希望分类页的标题显示为中文的分类，那么我们可以修改将title: tags 修改为title: 标签。接着我们需要修改这个文件，最终为：12345---title: 标签date: 2018-11-25 13:47:40type: "tags"--- 最后保存文件。 给文章添加“tags”属性，划分类别将需要分类的文章添加categories属性。例如：1234567---title: Hexo-next主题博客博文插入图片date: 2018-11-24 22:22:31tags:- 前端- hexo主题--- 这样这篇文章就有前端和hexo主题两个标签了。效果如下: 设置创建博文时自动添加分类以及标签选项hexo主题创建博文时默认是没有分类以及标签选项的，所以我们如果要给文章添加分类和标签属性的时候，可能会需要先创建一篇博文，然后去博文的md文件中自己添加这两个属性，这样比较麻烦。所以呢，我们可以通过设置默认的文章模版内容来简化这个操作。 修改post.md文件我们打开MySelfBlog/scaffolds/post.md文件（文章模版文件），修改成：123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories:--- 保存文件后，我们以后创建新文章的时候，页面里就会自动生成分类和标签项了，我们只需要写入对应的类别和标签就OK了，当然你也可以在这个模版页面自己添加一些自己的需求。]]></content>
      <categories>
        <category>hexo-next配置</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-next主题博客自定义配置Fork me on github]]></title>
    <url>%2Fpost%2Fb2257057.html</url>
    <content type="text"><![CDATA[在左上角或右上角实现fork me on github效果如下：首先我们可以选择在GitHub Ribbons或GitHub Corners选择一款你喜欢的挂饰，拷贝方框内的代码：将复制的代码，添加到MySelfBlog/themes/next/layout/_layout.swig 文件中，添加位置在1&lt;div class="headband"&gt;&lt;/div&gt; 如图:注意：要将自己github 的网址填写在对应位置:1&lt;a href="你的Github网址" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"&gt; 例如:1&lt;a href="https://github.com/zikunfucc" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"&gt; 自定义挂饰的部分样式样式源码示例:1&lt;svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"&gt; 修改挂饰的大小:1width="80" height="80" 修改挂饰的颜色:1style="fill:#222; color:#fff; 修改挂饰的位置（左方或者右方）:左方:1left: 0; 右方:1right: 0; 在修改了挂饰的位置后，可能还相应的需要修改挂饰的旋转方向:头朝左方:1transform:scale(-1,1); 头朝右方:1删去transform:scale(-1,1); 如果读者有什么其他样式的修改可以告诉我，我将不定期修改，让大家能获得一个更为完善的博客配置文章。]]></content>
      <categories>
        <category>hexo-next配置</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-next主题博客博文插入图片]]></title>
    <url>%2Fpost%2Fce47f76.html</url>
    <content type="text"><![CDATA[博文插入图片外部引用将需要插入文章的图片上传到某个图床上,例如新浪微博图床，得到这张图片的外链，例如 外链示例1http://wx3.sinaimg.cn/large/006zoO1wgy1fxjjq11udrj30go0aewfn.jpg 然后我们将这个保存了的外链实例,以markdown编辑语法写入博文中:1![图片标题](外链) 就可以得到最终效果。 内部引用（本地导入）方法一（安装相关插件）：修改博客配置文件参数在MySelfBlog/_config.yml文件中使用Ctrl+F查找post_asset_folder参数，如果显示的是post_asset_folder: false,那么我们就修改为1post_asset_folder: true 这样设置后，当你创建新博文时，Hexo会自动创建一个与博文同名且带上日期的文件夹，我们需要将该文章的所有资源（图片）全部放到那个文件夹里，这样我们就可以很方便的利用这些资源。 下载使用插件在博客根目录下通过命令行（终端），例如MySelfBlog目录，执行1npm install hexo-asset-image --save 正确引用方式在我们的博文中，如果你的博客已经是Hexo3以上版本的话，那么不能使用一般的1![图片标题](内部路径) 这样的markdown语法来引用图片和其他资源，这样可能会导致显示不正确，如下：所以正确的引用方法应该是：1&#123;% asset_img 你的图片.jpg 图片标题 %｝ 展示效果: 方法二(本地创建文件夹)在MySelfBlog/source 文件夹下创建一个images 文件夹，将你需要放置的图片放置在该文件夹下，然后调用1![星辰大海](/images/星辰大海.jpg) 效果如下：]]></content>
      <categories>
        <category>hexo-next配置</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-next主题博客背景修改]]></title>
    <url>%2Fpost%2F9bf7a4e1.html</url>
    <content type="text"><![CDATA[添加背景图博客路径MySelfBlog/themes/next/source/css/_custom/custom.styl找到对应的custom.styl文件，修改添加1234567body&#123; background:url(/images/bg1.png); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;&#125; url括号中的 (/images/bg.jpg) 对应着你所需要放置的背景图片，路径形式是相对于 themes/next/source 为根目录的路径，例如我的背景图片放置在 themes/next/source/images/bg1.png ,那么我对应的就是上面的路径，根据你们自己的路径填写正确即可。 其他区域相应修改(不一定需要，看个人)以上修改成功后，可能发现就像下面这样那么这个时候我们肯定是不能忍受的，那么我的选择是将文章板块，以及下方的评论系统的背景色调修改成原先的白色底色，这样才能获得一个单独修改背景图片的博客页面。修改的部分在我们原先的路径,themes/next/source/css/_custom/custom.styl处修改为：1234567891011121314151617181920212223@media screen and (min-width:1200px) &#123; // 添加背景图 body &#123; background-image:url(/images/bg1.png); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center; &#125; // 修改文章的背景色和透明度 .post &#123; background: #fff; opacity: 0.9; &#125; // 修改评论系统的背景色和透明度 .comments &#123; background: #fff; opacity: 0.9; &#125; &#125; 这样修改完了，我们就能看到博客页面成功的恢复成了我们所期望的样子，如下: 如果读者发现自己的博客修改后还有部分板块颜色被背景色同化，那么可以自己F12或者在那个板块下审查元素，寻找对应板块的名称，自己去在custom.styl文件中设置该区域的背景色。]]></content>
      <categories>
        <category>hexo-next配置</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
